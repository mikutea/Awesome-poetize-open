#!/bin/bash
## 作者: LeapYa
## 修改时间: 2025-09-19
## 描述: Poetize 博客系统全局管理命令
## 版本: 1.4.1

# 定义颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 函数
info() { echo -e "${BLUE}[信息]${NC} $1"; }
success() { echo -e "${GREEN}[成功]${NC} $1"; }
error() { echo -e "${RED}[失败]${NC} $1"; }
warning() { echo -e "${YELLOW}[警告]${NC} $1"; }

# 检查用户权限
check_user_permissions() {
    # 检查是否为root用户
    if [ "$EUID" -eq 0 ]; then
        return 0  # root用户，权限充足
    fi
    
    # 检查是否在docker组中
    if groups "$USER" 2>/dev/null | grep -q "\bdocker\b"; then
        return 0  # 在docker组中，权限充足
    fi
    
    # 检查是否有sudo权限
    if sudo -n true 2>/dev/null; then
        # 检查当前是否以sudo方式运行
        if [ -z "$SUDO_USER" ]; then
            warning "当前用户不在docker组中，但具有sudo权限"
            warning "建议使用sudo运行以确保Docker访问权限："
            printf "  ${YELLOW}推荐方式：${NC} sudo poetize [选项]\n"
            printf "  ${YELLOW}或添加到docker组：${NC} sudo usermod -aG docker $USER && newgrp docker\n"
        else
            info "以sudo权限运行，权限充足"
        fi
        return 0  # 有sudo权限，可以继续
    fi
    
    # 权限不足
    error "权限不足！当前用户既不是root用户，也不在docker组中，且无sudo权限"
    error "请执行以下操作之一："
    printf "  ${YELLOW}1. 切换到root用户：${NC} su -\n"
    printf "  ${YELLOW}2. 切换到有sudo权限的用户${NC}\n"
    printf "  ${YELLOW}3. 将当前用户添加到docker组：${NC} sudo usermod -aG docker $USER\n"
    printf "  ${YELLOW}4. 使用sudo运行：${NC} sudo poetize [选项]\n"
    exit 1
}

# 检查Docker和Docker Compose
check_docker() {
    if ! command -v docker &> /dev/null; then
        error "Docker未安装或未在PATH中"
        exit 1
    fi
    
    # 检查用户权限
    check_user_permissions
    
    # 尝试访问Docker
    if ! docker info &> /dev/null; then
        # 如果直接访问失败，尝试使用sudo
        if [ "$EUID" -ne 0 ] && ! groups "$USER" 2>/dev/null | grep -q "\bdocker\b"; then
            if sudo docker info &> /dev/null 2>&1; then
                warning "使用sudo权限访问Docker"
                DOCKER_COMPOSE_CMD="sudo docker-compose"
                # 重新定义docker命令为sudo版本
                alias docker='sudo docker' 2>/dev/null || true
            else
                error "Docker服务未运行或权限不足"
                exit 1
            fi
        else
            error "Docker服务未运行"
            exit 1
        fi
    fi
    
    # 检查docker-compose或docker compose
    if command -v docker-compose &> /dev/null; then
        DOCKER_COMPOSE_CMD="${DOCKER_COMPOSE_CMD:-docker-compose}"
    elif docker compose version &> /dev/null 2>&1 || sudo docker compose version &> /dev/null 2>&1; then
        DOCKER_COMPOSE_CMD="${DOCKER_COMPOSE_CMD:-docker} compose"
    else
        error "Docker Compose未安装"
        exit 1
    fi
}

# 显示帮助信息
show_help() {
    printf "\n"
    printf "${GREEN}██████╗  ██████╗ ███████╗████████╗██╗███████╗███████╗${NC}\n"
    printf "${GREEN}██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝██║╚══███╔╝██╔════╝${NC}\n"
    printf "${GREEN}██████╔╝██║   ██║█████╗     ██║   ██║  ███╔╝ █████╗${NC}\n"
    printf "${GREEN}██╔═══╝ ██║   ██║██╔══╝     ██║   ██║ ███╔╝  ██╔══╝${NC}\n"
    printf "${GREEN}██║     ╚██████╔╝███████╗   ██║   ██║███████╗███████╗${NC}\n"
    printf "${GREEN}╚═╝      ╚═════╝ ╚══════╝   ╚═╝   ╚═╝╚══════╝╚══════╝${NC}\n"
    printf "\n"
    printf "${CYAN}POETIZE 博客系统全局管理工具${NC}\n"
    printf "\n"
    printf "${BLUE}使用方法:${NC}\n"
    printf "  poetize [选项]\n"
    printf "\n"
    printf "${BLUE}服务管理:${NC}\n"
    printf "  -status                   查看所有服务状态\n"
    printf "  -start, -up               启动所有服务\n"
    printf "  -stop, -down              停止所有服务\n"
    printf "  -restart                  重启所有服务\n"
    printf "  -update                   更新系统到最新版本\n"
    printf "  -deploy, -bushu, -bs      执行部署脚本\n"
    printf "\n"
    printf "${BLUE}系统管理:${NC}\n"
    printf "  -qianyi, -migrate, -qy    执行博客迁移到远程服务器\n"
    printf "  -uninstall                卸载当前项目的Poetize实例\n"
    printf "  -uninstall-all            完全卸载所有Poetize系统\n"
    printf "\n"
    printf "${BLUE}日志和监控:${NC}\n"
    printf "  -logs [服务名]            查看服务日志\n"
    printf "  -logs-follow [服务名]     实时跟踪服务日志\n"
    printf "  -health                   检查服务健康状态\n"
    printf "\n"
    printf "${BLUE}信息查看:${NC}\n"
    printf "  -info                     显示系统和项目信息\n"
    printf "  -version, -v              显示版本信息\n"
    printf "  -help, -h                 显示此帮助信息\n"
    printf "\n"
    printf "${BLUE}常用示例:${NC}\n"
    printf "  poetize -status           查看服务状态\n"
    printf "  poetize -restart          重启所有服务\n"
    printf "  poetize -logs nginx       查看nginx日志\n"
    printf "\n"
}

# 显示版本信息
show_version() {
    printf "${GREEN}POETIZE 管理工具 v1.3.1${NC}\n"
    printf "作者: LeapYa\n"
    printf "项目: Awesome-poetize-open\n"
}

find_project_dir() {
    # 查找所有匹配目录，排除常见系统目录
    dirs=()
    while IFS= read -r dir; do
    dirs+=("$dir")
    done < <(sudo find / \
    \( -path /proc -o -path /sys -o -path /dev -o -path /run \) -prune -o \
    -type d -name "Awesome-poetize-open*" -print 2>/dev/null)

    if [ ${#dirs[@]} -eq 0 ]; then
        echo "未发现poetize博客相关目录"
        exit 1
    elif [ ${#dirs[@]} -eq 1 ]; then
        echo "发现一个博客目录: ${dirs[0]}"
        cd "${dirs[0]}" || { echo "切换目录失败: ${dirs[0]}"; exit 1; }
    else
        echo "发现多个博客目录："
        for i in "${!dirs[@]}"; do
            printf "%d. %s\n" "$((i+1))" "${dirs[i]}"
        done

        # 交互输入
        read -rp "请选择要迁移的目录序号: " choice

        # 判断输入有效性
        if ! [[ "$choice" =~ ^[0-9]+$ ]] || (( choice < 1 || choice > ${#dirs[@]} )); then
            echo "无效的选择."
            exit 1
        fi

        target_dir="${dirs[$((choice-1))]}"
        echo "迁移目录: $target_dir"
        cd "$target_dir" || { echo "切换目录失败: $target_dir"; exit 1; }
    fi
}

# 查看服务状态
show_status() {
    info "正在检查POETIZE服务状态..."
    printf "\n"
    
    # 显示Docker容器状态
    printf "${CYAN}=== Docker 容器状态 ===${NC}\n"
    if sudo docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" --filter "name=poetize" | grep -q "poetize"; then
        sudo docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" --filter "name=poetize"
    else
        warning "未发现Poetize相关容器"
    fi
    
    printf "\n"
    
    # 显示服务健康状态
    printf "${CYAN}=== 服务健康状态 ===${NC}\n"
    
    # 检查主要服务（支持多实例）
    local base_services=("poetize-nginx" "poetize-java" "poetize-python" "poetize-mariadb" "poetize-prerender")
    
    # 获取所有运行中的poetize相关容器
    local running_containers=$(sudo docker ps --format "{{.Names}}" | grep "^poetize-" | sort)
    
    # 为每个基础服务类型检查所有实例
    for base_service in "${base_services[@]}"; do
        local found_instances=false
        
        # 检查该服务类型的所有实例
        while IFS= read -r container_name; do
            if [[ "$container_name" =~ ^${base_service}(-blog[0-9]+)?$ ]]; then
                found_instances=true
                local status=$(sudo docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "unknown")
                case "$status" in
                    "healthy")
                        printf "  ${GREEN}✓${NC} %-25s ${GREEN}健康${NC}\n" "$container_name"
                        ;;
                    "unhealthy")
                        printf "  ${RED}✗${NC} %-25s ${RED}不健康${NC}\n" "$container_name"
                        ;;
                    "starting")
                        printf "  ${YELLOW}⚠${NC} %-25s ${YELLOW}启动中${NC}\n" "$container_name"
                        ;;
                    *)
                        printf "  ${BLUE}?${NC} %-25s ${BLUE}运行中${NC}\n" "$container_name"
                        ;;
                esac
            fi
        done <<< "$running_containers"
        
        # 如果没有找到任何实例，显示未运行状态
        if [ "$found_instances" = false ]; then
            printf "  ${RED}✗${NC} %-25s ${RED}未运行${NC}\n" "$base_service"
        fi
    done
    
    printf "\n"
    
    # 显示端口占用情况
    printf "${CYAN}=== 端口占用情况 ===${NC}\n"
    local ports=("80" "443")
    for port in "${ports[@]}"; do
        if netstat -tuln 2>/dev/null | grep -q ":${port} " || ss -tuln 2>/dev/null | grep -q ":${port} "; then
            printf "  ${GREEN}✓${NC} 端口 %-6s ${GREEN}已占用${NC}\n" "$port"
        else
            printf "  ${RED}✗${NC} 端口 %-6s ${RED}未占用${NC}\n" "$port"
        fi
    done
    
    printf "\n"
}

# 启动服务
start_services() {
    find_project_dir
    info "正在启动Poetize服务..."
    
    if $DOCKER_COMPOSE_CMD up -d; then
        success "服务启动成功"
        sleep 3
        show_status
    else
        error "服务启动失败"
        exit 1
    fi
}

# 停止服务
stop_services() {
    find_project_dir
    info "正在停止Poetize服务..."
    if $DOCKER_COMPOSE_CMD down; then
        success "服务停止成功"
    else
        error "服务停止失败"
        exit 1
    fi
}

# 重启服务
restart_services() {
    find_project_dir
    info "正在重启Poetize服务..."

    if $DOCKER_COMPOSE_CMD restart; then
        success "服务重启成功"
        sleep 3
        show_status
    else
        error "服务重启失败"
        exit 1
    fi
}

# 卸载当前项目服务
uninstall_services() {
    local skip_confirm=false
    
    # 检查是否有--skip-confirm参数
    if [ "$1" = "--skip-confirm" ]; then
        skip_confirm=true
    fi
    
    # 只有在非跳过模式下才查找项目目录和显示警告
    if [ "$skip_confirm" = false ]; then
        find_project_dir
        warning "此操作将卸载当前项目的POETIZE系统，包括删除相关容器和数据卷！"
        printf "${RED}警告: 这将删除当前项目的博客数据，此操作不可逆！${NC}\n"
        printf "\n"
        
        # 确认操作
        read -rp "请输入 'YES' 确认卸载当前项目: " confirm
        if [ "$confirm" != "YES" ]; then
            info "卸载操作已取消"
            exit 0
        fi
        info "正在卸载当前项目的POETIZE系统..."
    fi
    
    # 获取当前项目的容器名称（用于识别相关卷）
    local project_containers=$($DOCKER_COMPOSE_CMD ps -q 2>/dev/null || true)
    local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
    
    # 停止并删除当前项目的容器和卷
    info "停止并删除当前项目容器..."
    $DOCKER_COMPOSE_CMD down -v --remove-orphans
    
    # 仅清理通过docker-compose创建的项目专属卷
    info "检查并清理当前项目专属数据卷..."
    
    # 获取当前项目的docker-compose生成的卷名前缀
    local compose_project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
    
    # 清理当前项目的卷（通过docker-compose down -v应该已经删除了，但防止遗漏）
    local project_specific_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "^${compose_project_name}_" || true)
    if [ -n "$project_specific_volumes" ]; then
        info "删除当前项目专属数据卷..."
        while IFS= read -r volume; do
            info "删除数据卷: $volume"
            sudo docker volume rm "$volume" -f 2>/dev/null || true
        done <<< "$project_specific_volumes"
        success "已删除当前项目专属数据卷"
    else
        info "当前项目无需清理额外数据卷（已通过docker-compose清理）"
    fi
    
    success "当前项目的POETIZE系统已卸载"
    
    # 如果是跳过确认模式（用于更新流程），则删除项目目录
    if [ "$skip_confirm" = true ]; then
        local current_dir=$(pwd)
        info "正在删除项目目录..."
        cd ..
        sudo rm -rf "$(basename "$current_dir")"
        info "项目目录已删除"
    else
        warning "如需重新安装，请运行: poetize -deploy"
    fi
}

# 完全卸载所有Poetize系统
uninstall_all_services() {
    warning "此操作将完全卸载所有POETIZE系统，包括删除所有容器、镜像、卷和数据！"
    printf "${RED}警告: 这将删除所有博客数据，此操作不可逆！${NC}\n"
    printf "\n"
    
    # 确认操作
    read -rp "请输入 'YES' 确认完全卸载所有POETIZE系统: " confirm
    if [ "$confirm" != "YES" ]; then
        info "卸载操作已取消"
        exit 0
    fi
    
    info "正在完全卸载所有POETIZE系统..."
    
    # 删除所有poetize相关的容器（包括停止的）
    local containers=$(sudo docker ps -a --format "{{.Names}}" | grep "^poetize-" || true)
    if [ -n "$containers" ]; then
        info "删除所有POETIZE容器..."
        echo "$containers" | xargs sudo docker rm -f
    fi
    
    # 删除所有poetize相关的镜像
    local images=$(sudo docker images --format "{{.Repository}}:{{.Tag}}" | grep "poetize" || true)
    if [ -n "$images" ]; then
        info "删除所有POETIZE镜像..."
        echo "$images" | xargs sudo docker rmi -f
    fi
    
    # 删除所有poetize相关的卷（包括默认卷名和带后缀的卷）
    info "检查并删除所有POETIZE数据卷..."
    
    # 定义需要清理的卷名称模式
    local volume_patterns=(
        "mysql_data"
        "redis_data" 
        "certbot-etc"
        "certbot-var"
        "web-root"
        "poetize_node_modules"
        "im_node_modules"
        "poetize_ui_dist"
        "poetize_im_dist"
        "poetize_uploads"
        "ollama_data"
    )
    
    local volumes_to_delete=()
    
    # 1. 查找包含POETIZE的卷
    local poetize_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "poetize" || true)
    if [ -n "$poetize_volumes" ]; then
        while IFS= read -r volume; do
            volumes_to_delete+=("$volume")
        done <<< "$poetize_volumes"
    fi
    
    # 2. 查找所有可能的默认卷名（包括各种前缀和后缀）
    for pattern in "${volume_patterns[@]}"; do
        # 完全匹配的卷名
        local exact_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "^${pattern}$" || true)
        if [ -n "$exact_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$exact_volumes"
        fi
        
        # 带项目前缀的卷名
        local prefixed_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "_${pattern}$" || true)
        if [ -n "$prefixed_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$prefixed_volumes"
        fi
        
        # 带后缀的卷名（blog2、blog3等）
        local suffixed_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "^${pattern}-blog[0-9]*$" || true)
        if [ -n "$suffixed_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$suffixed_volumes"
        fi
        
        # 带前缀和后缀的卷名
        local complex_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "_${pattern}-blog[0-9]*$" || true)
        if [ -n "$complex_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$complex_volumes"
        fi
    done
    
    # 去重并删除卷
    if [ ${#volumes_to_delete[@]} -gt 0 ]; then
        # 去重
        local unique_volumes=($(printf "%s\n" "${volumes_to_delete[@]}" | sort -u))
        
        info "找到 ${#unique_volumes[@]} 个POETIZE数据卷，准备删除..."
        for volume in "${unique_volumes[@]}"; do
            info "删除数据卷: $volume"
            sudo docker volume rm "$volume" -f 2>/dev/null || true
        done
        success "已删除 ${#unique_volumes[@]} 个POETIZE数据卷"
    else
        info "未找到需要清理的POETIZE数据卷"
    fi
    
    # 删除所有poetize相关的网络
    local networks=$(sudo docker network ls --format "{{.Name}}" | grep "poetize" || true)
    if [ -n "$networks" ]; then
        info "删除所有POETIZE网络..."
        echo "$networks" | xargs sudo docker network rm
    fi
    
    # 清理未使用的Docker资源
    info "清理未使用的Docker资源..."
    sudo docker system prune -f
    
    success "所有POETIZE系统已完全卸载"
    warning "如需重新安装，请运行: poetize -deploy"
}

# 查看日志
show_logs() {
    local service="$1"
    local follow="$2"
    find_project_dir
    if [ -n "$service" ]; then
        info "正在查看 $service 服务日志..."
        if [ "$follow" = "true" ]; then
            $DOCKER_COMPOSE_CMD logs -f "$service"
        else
            $DOCKER_COMPOSE_CMD logs --tail=100 "$service"
        fi
    else
        info "正在查看所有服务日志..."
        if [ "$follow" = "true" ]; then
            $DOCKER_COMPOSE_CMD logs -f
        else
            $DOCKER_COMPOSE_CMD logs --tail=50
        fi
    fi
}

# 执行迁移
run_migration() {
    info "正在执行博客迁移..."
    # 查找项目目录
    find_project_dir
    if [ ! -f "migrate.sh" ]; then
        error "迁移脚本 migrate.sh 不存在"
        exit 1
    fi
    
    sudo chmod +x migrate.sh
    sudo ./migrate.sh
}

# 执行部署
run_deployment() {
    info "正在启动POETIZE博客系统部署向导..."
    printf "\n"
    
    # 检查是否已在项目目录中
    if [ -f "deploy.sh" ]; then
        warning "检测到当前目录已有POETIZE项目"
        printf "\n"
        read -rp "是否在当前目录重新部署？(y/N): " redeploy_confirm
        case "$redeploy_confirm" in
            [Yy]|[Yy][Ee][Ss])
                info "在当前目录重新部署..."
                find_project_dir
                sudo chmod +x deploy.sh
                sudo ./deploy.sh
                return 0
                ;;
            *)
                info "取消当前目录重新部署"
                ;;
        esac
    fi
    
    # 询问安装位置
    printf "${CYAN}请选择POETIZE博客系统的安装位置：${NC}\n"
    printf "\n"
    printf "当前目录: $(pwd)\n"
    printf "\n"
    
    # 默认安装目录建议
    local default_install_dir="$HOME/poetize-blog"
    
    printf "请输入安装目录路径\n"
    printf "${YELLOW}提示: 直接回车使用默认路径 ($default_install_dir)${NC}\n"
    read -rp "安装目录: " install_dir
    
    # 使用默认目录或用户指定目录
    if [ -z "$install_dir" ]; then
        install_dir="$default_install_dir"
    fi
    
    # 展开波浪号
    install_dir=$(eval echo "$install_dir")
    
    # 验证目录路径
    if [ -d "$install_dir" ] && [ "$(ls -A "$install_dir" 2>/dev/null)" ]; then
        warning "目录 $install_dir 已存在且不为空"
        printf "\n"
        read -rp "是否继续在此目录安装？这可能会覆盖现有文件 (y/N): " continue_install
        case "$continue_install" in
            [Yy]|[Yy][Ee][Ss])
                info "继续在指定目录安装..."
                ;;
            *)
                info "安装已取消"
                exit 0
                ;;
        esac
    fi
    
    # 创建安装目录
    info "准备安装目录: $install_dir"
    mkdir -p "$install_dir"
    cd "$install_dir"
    
    # 显示安装信息
    printf "\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "${GREEN}    POETIZE 博客系统一键部署${NC}\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "\n"
    printf "安装位置: ${CYAN}$install_dir${NC}\n"
    printf "\n"
    
    # 执行一键部署脚本
    bash <(curl -sL deploy.leapya.com)
}

# 显示系统信息
show_info() {
    printf "\n"
    printf "${CYAN}=== 系统信息 ===${NC}\n"
    printf "操作系统: $(uname -s)\n"
    printf "内核版本: $(uname -r)\n"

    # 检测Linux发行版本
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        printf "发行版本: $PRETTY_NAME\n"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        printf "发行版本: $DISTRIB_DESCRIPTION\n"
    elif command -v lsb_release >/dev/null 2>&1; then
        printf "发行版本: $(lsb_release -d | cut -f2)\n"
    elif [ -f /etc/debian_version ]; then
        printf "发行版本: Debian $(cat /etc/debian_version)\n"
    elif [ -f /etc/redhat-release ]; then
        printf "发行版本: $(cat /etc/redhat-release)\n"
    else
        printf "发行版本: 未知\n"
    fi
    printf "架构: $(uname -m)\n"
    printf "\n"
    
    printf "${CYAN}=== Docker 信息 ===${NC}\n"
    printf "Docker版本: $(sudo docker --version 2>/dev/null || echo '未安装')\n"
    printf "Docker Compose: $DOCKER_COMPOSE_CMD\n"
    printf "\n"
    
    get_project_info
}


# 获取项目信息
get_project_info() {
    printf "${CYAN}=== 项目信息 ===${NC}\n"
    
    # 获取脚本实际位置
    local script_path="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || realpath "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
    local script_dir="$(dirname "$script_path")"
    
    local project_dirs=()
    local search_paths=("/usr/local/bin" "$HOME" "/opt" "/var/www" "$(pwd)")
    
    # 去重搜索路径
    local unique_paths=($(printf "%s\n" "${search_paths[@]}" | sort -u))
    
    for search_path in "${unique_paths[@]}"; do
        if [ -d "$search_path" ]; then
            while IFS= read -r -d '' dir; do
                if [ -f "$dir/docker-compose.yml" ] || [ -f "$dir/docker-compose.yaml" ]; then
                    # 检查是否为Poetize项目
                    if grep -q "poetize" "$dir/docker-compose.yml" 2>/dev/null || grep -q "poetize" "$dir/docker-compose.yaml" 2>/dev/null; then
                        project_dirs+=("$dir")
                    fi
                fi
            done < <(find "$search_path" -maxdepth 3 -type d -name "*poetize*" -print0 2>/dev/null)
        fi
    done
    
    # 显示找到的项目实例
    if [ ${#project_dirs[@]} -eq 0 ]; then
        printf "${RED}未发现POETIZE项目！${NC}\n"
    else
        for i in "${!project_dirs[@]}"; do
            local project_dir="${project_dirs[i]}"
            printf "%d. %s\n" "$((i+1))" "$project_dir"
            
            # 检查容器状态
            local compose_file=""
            if [ -f "$project_dir/docker-compose.yml" ]; then
                compose_file="$project_dir/docker-compose.yml"
            elif [ -f "$project_dir/docker-compose.yaml" ]; then
                compose_file="$project_dir/docker-compose.yaml"
            fi
            
            if [ -f "$compose_file" ]; then
                local project_name=$(basename "$project_dir" | tr '[:upper:]' '[:lower:]')

                if [[ $project_dir =~ ([0-9]+)$ ]]; then
                    num="-blog${BASH_REMATCH[1]}"
                else
                    num=""
                fi
                
                containers=(
                poetize-prerender
                poetize-certbot
                poetize-nginx
                poetize-python
                poetize-java
                poetize-mariadb
                poetize-redis
                )

                # 拼接新的容器名列表
                new_containers=()
                for c in "${containers[@]}"; do
                    if [ -n "$num" ]; then
                        new_containers+=("${c}${num}")
                    else
                        new_containers+=("$c")
                    fi
                done



                unhealthy=()

                for c in "${new_containers[@]}"; do
                    status=$(sudo docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no-healthcheck{{end}}' "$c" 2>/dev/null)
                    if [[ "$status" == "unhealthy" ]]; then
                        unhealthy+=("$c")
                    fi
                done

                # 输出结果
                if [ ${#unhealthy[@]} -eq 0 ]; then
                    echo -e "   ${GREEN}√${NC} 项目正常运行中"
                else
                    project_num=1
                    for c in "${unhealthy[@]}"; do
                        echo "   $project_num) ${RED}✗${NC} $c (${status})容器非正常状态，请检查日志！"
                        ((project_num++))
                    done
                fi

            fi
            
            project_nginx_conf=$project_dir/docker/nginx/default.https.conf

            echo -e "   服务端口: ${BLUE}$(sudo docker port "poetize-nginx${num}" 2>/dev/null  | grep "0.0.0.0" | grep "tcp" | awk -F '[:/]' '{print $1}' | tr '\n' ', ' | sed 's/,\s*$//')${NC}"
            
            project_nginx_domains=$(grep '^[[:space:]]*server_name' "$project_nginx_conf" \
            | sed -E 's/.*server_name[[:space:]]+([^;]+);/\1/' \
            | sort -u \
            | xargs \
            | tr ' ' ', ')

            echo -e "   访问域名: ${BLUE}$project_nginx_domains${NC}"


            printf "\n"
        done
    fi
    
    printf "${CYAN}=== 存储与资源 ===${NC}\n"
    
    # 获取系统资源信息
    local total_mem=$(free -h | awk '/^Mem:/ {print $2}')
    local used_mem=$(free -h | awk '/^Mem:/ {print $3}')
    local mem_percent=$(free | awk '/^Mem:/ {printf "%.1f", $3/$2*100}')
    
    # 磁盘使用情况
    local disk_usage=$(df -h / | awk 'NR==2 {print $3"/"$2" ("$5")"}')
    
    printf "系统内存: %s/%s (%.1f%%)\n" "$used_mem" "$total_mem" "$mem_percent"
    printf "根分区: %s\n" "$disk_usage"
    
    # Docker 相关资源
    if command -v docker >/dev/null 2>&1; then
        # Docker 数据目录大小
        local docker_root=$(sudo docker info --format '{{.DockerRootDir}}' 2>/dev/null || echo "/var/lib/docker")
        if [ -d "$docker_root" ]; then
            local docker_size=$(sudo du -sh "$docker_root" 2>/dev/null | cut -f1 || echo "未知")
            printf "Docker数据: %s (%s)\n" "$docker_size" "$docker_root"
        fi
    fi
    
    printf "\n"

    

    
    printf "\n"
}

# 检查服务健康状态
check_health() {
    info "正在检查服务健康状态..."
    printf "\n"

    local all_healthy=true
    local base_services=("poetize-nginx" "poetize-java" "poetize-python" "poetize-mariadb" "poetize-prerender")

    # 获取所有运行中的poetize相关容器
    local running_containers=$(sudo docker ps --format "{{.Names}}" | grep "^poetize-" | sort)

    # 为每个基础服务类型检查所有实例
    for base_service in "${base_services[@]}"; do
        local found_instances=false

        # 检查该服务类型的所有实例
        while IFS= read -r container_name; do
            if [[ "$container_name" =~ ^${base_service}(-blog[0-9]+)?$ ]]; then
                found_instances=true
                printf "${BLUE}检查 $container_name...${NC}\n"

                # 检查容器状态
                local container_status=$(sudo docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null)
                if [ "$container_status" != "running" ]; then
                    printf "  ${RED}✗ 容器未运行 (状态: $container_status)${NC}\n"
                    all_healthy=false
                    continue
                fi

                # 检查健康状态
                local health_status=$(sudo docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "no-healthcheck")
                case "$health_status" in
                    "healthy")
                        printf "  ${GREEN}✓ 健康检查通过${NC}\n"
                        ;;
                    "unhealthy")
                        printf "  ${RED}✗ 健康检查失败${NC}\n"
                        all_healthy=false
                        ;;
                    "starting")
                        printf "  ${YELLOW}⚠ 健康检查启动中${NC}\n"
                        ;;
                    "no-healthcheck")
                        printf "  ${BLUE}? 无健康检查配置${NC}\n"
                        ;;
                esac
            fi
        done <<< "$running_containers"

        # 如果没有找到任何实例，显示未运行状态
        if [ "$found_instances" = false ]; then
            printf "${RED}✗ $base_service 容器未运行${NC}\n"
            all_healthy=false
        fi
    done

    printf "\n"
    if [ "$all_healthy" = true ]; then
        success "所有服务健康状态良好"
    else
        warning "部分服务存在问题，请检查日志"
    fi
}

# ================================ UPDATE 命令相关函数 ================================

# 创建完整数据备份
create_full_backup() {
    info "开始创建完整数据备份..."
    
    # 创建备份目录（放在项目目录外的安全位置）
    local backup_timestamp=$(date +%Y%m%d_%H%M%S)
    local project_name=$(basename "$(pwd)")
    BACKUP_PROJECT_NAME="$project_name"
    BACKUP_DIR="/tmp/poetize_update_backup_${project_name}_${backup_timestamp}"
    mkdir -p "$BACKUP_DIR"
    
    info "备份目录: $BACKUP_DIR"
    info "备份位置: 系统临时目录（不会被卸载删除）"
    
    # 1. 备份数据库凭据
    info "备份数据库凭据..."
    if [ -f ".config/db_credentials.txt" ]; then
        mkdir -p "$BACKUP_DIR/.config"
        cp ".config/db_credentials.txt" "$BACKUP_DIR/.config/"
        success "数据库凭据备份完成"
    else
        warning "数据库凭据文件不存在，跳过备份"
    fi
    
    # 2. 读取数据库密码
    local db_root_password=""
    local db_user_password=""
    if [ -f ".config/db_credentials.txt" ]; then
        db_root_password=$(grep "数据库ROOT密码:" .config/db_credentials.txt | cut -d':' -f2 | tr -d ' ')
        db_user_password=$(grep "数据库poetize用户密码:" .config/db_credentials.txt | cut -d':' -f2 | tr -d ' ')
    fi
    
    # 3. 备份数据库
    info "备份数据库数据..."
    local mariadb_container=$(sudo docker ps --format "{{.Names}}" | grep "mariadb" | head -1)
    if [ -n "$mariadb_container" ] && [ -n "$db_root_password" ]; then
        info "使用MariaDB容器: $mariadb_container"
        if sudo docker exec "$mariadb_container" mariadb-dump -u root -p"$db_root_password" --single-transaction --routines --triggers --databases poetize > "$BACKUP_DIR/poetry.sql"; then
            success "数据库备份完成"
        else
            error "数据库备份失败"
            return 1
        fi
    else
        warning "MariaDB容器未运行或数据库密码未找到，跳过数据库备份"
    fi
    
    # 4. 备份Python配置文件
    info "备份Python配置文件..."
    if [ -d "py/data" ]; then
        mkdir -p "$BACKUP_DIR/py"
        cp -r "py/data" "$BACKUP_DIR/py/"
        success "Python配置文件备份完成"
    else
        warning "Python配置目录不存在，跳过备份"
    fi
    
    # 5. 备份用户上传文件
    info "备份用户上传文件..."
    local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
    local uploads_volume="${project_name}_poetize_uploads"
    
    # 检查uploads volume是否存在
    local actual_uploads_volume=$(sudo docker volume ls --format "{{.Name}}" | grep "$uploads_volume" | head -1)
    if [ -n "$actual_uploads_volume" ]; then
        info "找到用户上传文件volume: $actual_uploads_volume"
        # 检查volume中是否有数据
        if sudo docker run --rm -v "$actual_uploads_volume":/data alpine sh -c "[ -d /data/. ] && [ \"\$(ls -A /data/. 2>/dev/null)\" ]"; then
            info "导出用户上传文件..."
            if sudo docker run --rm -v "$actual_uploads_volume":/data -v "$(pwd)/$BACKUP_DIR":/backup alpine tar -czf "/backup/uploads_backup.tar.gz" -C /data .; then
                success "用户上传文件备份完成"
            else
                warning "用户上传文件备份失败"
            fi
        else
            info "用户上传文件volume为空，跳过备份"
        fi
    else
        info "未找到用户上传文件volume，跳过备份"
    fi
    
    # 6. 备份Redis数据
    info "备份Redis数据..."
    local redis_volume="${project_name}_redis_data"
    local actual_redis_volume=$(sudo docker volume ls --format "{{.Name}}" | grep "redis_data" | head -1)
    if [ -n "$actual_redis_volume" ]; then
        info "找到Redis数据volume: $actual_redis_volume"
        # 检查volume中是否有数据
        if sudo docker run --rm -v "$actual_redis_volume":/data alpine sh -c "[ -d /data/. ] && [ \"\$(ls -A /data/. 2>/dev/null)\" ]"; then
            info "导出Redis数据..."
            if sudo docker run --rm -v "$actual_redis_volume":/data -v "$(pwd)/$BACKUP_DIR":/backup alpine tar -czf "/backup/redis_backup.tar.gz" -C /data .; then
                success "Redis数据备份完成"
            else
                warning "Redis数据备份失败"
            fi
        else
            info "Redis数据volume为空，跳过备份"
        fi
    else
        info "未找到Redis数据volume，跳过备份"
    fi
    
    # 7. 备份Prerender预渲染文件（仅备份prerender目录，不备份前端构建文件）
    info "备份Prerender预渲染文件..."
    local ui_dist_volume="${project_name}_poetize_ui_dist"
    local actual_ui_dist_volume=$(sudo docker volume ls --format "{{.Name}}" | grep "poetize_ui_dist" | head -1)
    if [ -n "$actual_ui_dist_volume" ]; then
        info "找到UI构建文件volume: $actual_ui_dist_volume"
        # 检查volume中是否有预渲染文件目录
        if sudo docker run --rm -v "$actual_ui_dist_volume":/data alpine sh -c "[ -d /data/prerender ] && [ \"\$(ls -A /data/prerender 2>/dev/null)\" ]"; then
            info "导出预渲染文件（仅prerender目录）..."
            if sudo docker run --rm -v "$actual_ui_dist_volume":/data -v "$(pwd)/$BACKUP_DIR":/backup alpine tar -czf "/backup/prerender_backup.tar.gz" -C /data prerender; then
                success "预渲染文件备份完成"
            else
                warning "预渲染文件备份失败"
            fi
        else
            info "预渲染文件目录为空或不存在，跳过备份"
        fi
    else
        info "未找到UI构建文件volume，跳过预渲染文件备份"
    fi

    # 8. 备份nginx配置中的域名信息
    info "备份域名配置信息..."
    local extracted_domains=$(extract_domains_from_nginx_config 2>/dev/null || echo "")
    if [ -n "$extracted_domains" ]; then
        echo "$extracted_domains" > "$BACKUP_DIR/domains.txt"
        success "域名配置备份完成: $extracted_domains"
    else
        info "未找到域名配置，跳过域名备份"
    fi
    
    # 8. 创建备份清单
    info "创建备份清单..."
    cat > "$BACKUP_DIR/backup_manifest.txt" << EOF
POETIZE系统备份清单
备份时间: $(date '+%Y-%m-%d %H:%M:%S')
备份目录: $BACKUP_DIR
项目目录: $(pwd)

备份内容:
- 数据库数据: poetry.sql
- 数据库凭据: .config/db_credentials.txt
- Python配置: py/data/
- 用户上传文件: uploads_backup.tar.gz
- Redis缓存数据: redis_backup.tar.gz
- 域名配置: domains.txt

注意: 此备份用于系统更新，包含恢复系统所需的所有关键数据
EOF
    
    success "完整数据备份创建完成: $BACKUP_DIR"
    return 0
}

# 从nginx配置中提取域名
extract_domains_from_nginx_config() {
    local nginx_config_file="docker/nginx/default.https.conf"
    local domains=""
    
    if [ -f "$nginx_config_file" ]; then
        info "从nginx配置文件中提取域名..." >&2
        # 提取server_name行中的域名，排除example.com
        domains=$(grep "server_name" "$nginx_config_file" | sed 's/server_name \(.*\);/\1/' | tr -d ' ' | tr ';' '\n' | grep -v "example.com" | grep -v "^$" | sort -u)
        
        if [ -n "$domains" ]; then
            info "提取到域名: $domains" >&2
            echo "$domains"
            return 0
        else
            warning "未找到有效域名或只有默认域名" >&2
            return 1
        fi
    else
        warning "nginx配置文件不存在: $nginx_config_file" >&2
        return 1
    fi
}


# 检测是否为国内环境
is_china_environment() {
    # 方法1: 检测网络连通性
    if command -v curl &>/dev/null; then
        # 检测是否能访问Google（国内通常被屏蔽）
        if ! curl -s --connect-timeout 3 --max-time 5 "https://www.google.com" >/dev/null 2>&1; then
            # 无法访问Google，再检测是否能访问国内镜像源
            if curl -s --connect-timeout 3 --max-time 5 "http://mirrors.aliyun.com" >/dev/null 2>&1; then
                return 0  # 无法访问Google但能访问阿里云镜像，判断为国内环境
            fi
        fi
    elif command -v ping &>/dev/null; then
        # 如果没有curl，使用ping检测
        if ! ping -c 1 -W 3 www.google.com >/dev/null 2>&1; then
            # 无法ping通Google，再检测国内镜像源
            if ping -c 1 -W 3 mirrors.aliyun.com >/dev/null 2>&1; then
                return 0  # 无法ping通Google但能ping通阿里云镜像，判断为国内环境
        fi
      fi
    fi
    
    # 方法2: 检测IP地址归属
    local ip_check_result=""
    if command -v curl &>/dev/null; then
        # 尝试获取公网IP并检测归属地
        ip_check_result=$(curl -s --connect-timeout 5 --max-time 10 "http://ip-api.com/json" 2>/dev/null | grep -o '"country":"China"' || echo "")
        if [[ -n "$ip_check_result" ]]; then
            return 0  # 是国内环境
        fi
    fi
    
    # 方法3: 检测时区
    if [[ -f /etc/timezone ]]; then
        if grep -q "Asia/Shanghai\|Asia/Chongqing" /etc/timezone; then
            return 0  # 是国内环境
        fi
    fi
    
    # 方法4: 检测locale
    if [[ "$LANG" =~ zh_CN || "$LC_ALL" =~ zh_CN ]]; then
        return 0  # 是国内环境
    fi
    
    return 1  # 不是国内环境
}

# 拉取项目代码
pull_code_on_target() {
    info "拉取项目代码..."
    
    local IS_CHINA_ENV=false

    if is_china_environment; then
        IS_CHINA_ENV=true
    fi

    local git_url
    if [ "$IS_CHINA_ENV" = true ]; then
        git_url="https://gitee.com/leapya/poetize.git"
    else
        git_url="https://github.com/LeapYa/Awesome-poetize-open.git"
    fi
    
    info "使用仓库地址: $git_url"

    # 安装必要工具
    if command -v apt-get &>/dev/null; then
        sudo apt-get update && sudo apt-get install -y git curl
    elif command -v yum &>/dev/null; then
        sudo yum install -y git curl
    elif command -v dnf &>/dev/null; then
        sudo dnf install -y git curl
    elif command -v zypper &>/dev/null; then
        sudo zypper install -y git curl
    elif command -v pacman &>/dev/null; then
        sudo pacman -S --needed git curl
    elif command -v apk &>/dev/null; then
        sudo apk add --update-cache git curl
    else
        error '不支持的包管理器，请手动安装git和curl'
        exit 1
    fi
    
    # 克隆项目
    git clone --depth 1 $git_url $BACKUP_PROJECT_NAME
    
    # 检查是否成功
    if [ -d "$BACKUP_PROJECT_NAME" ] && [ -f "$BACKUP_PROJECT_NAME/deploy.sh" ]; then
        success '项目代码拉取成功'
        cd "$BACKUP_PROJECT_NAME"
        return 0
    else
        error '项目代码拉取失败'
        exit 1
    fi
}

# 重新安装最新系统
reinstall_latest_system() {
    info "开始重新安装最新版本的POETIZE系统..."

    # 拉取项目
    pull_code_on_target
    # 恢复数据库
    cp $BACKUP_DIR/poetry.sql poetize-server/sql/poetry.sql
    # 恢复Python文件配置
    cp -r $BACKUP_DIR/.config ./

    # 构建poetize系统安装命令
    local domains=""
    local backup_domains_file="$BACKUP_DIR/domains.txt"
    
    # 从备份中读取域名，如果没有备份则从当前配置中提取
    if [ -f "$backup_domains_file" ]; then
        domains=$(cat "$backup_domains_file" 2>/dev/null)
        info "从备份中读取到域名: $domains"
    else
        domains=$(extract_domains_from_nginx_config 2>/dev/null || echo "")
        if [ -n "$domains" ]; then
            info "从当前配置中提取到域名: $domains"
        fi
    fi
    
    # 构建安装命令
    local deploy_cmd="bash <(curl -sL deploy.leapya.com)"
    
    if [ -n "$domains" ]; then
        info "使用域名进行自动安装..."
        # 为每个域名添加-d参数
        for domain in $domains; do
            deploy_cmd="$deploy_cmd -d $domain"
        done
        info "完整安装命令: $deploy_cmd"
    else
        info "未找到域名配置，将使用交互式域名输入"
    fi
    
    # 执行安装命令
    eval "$deploy_cmd"
    
    success "最新版本系统安装完成"
    return 0
}

# 恢复完整备份
restore_full_backup() {
    info "开始恢复用户数据和配置..."
    
    # 检查全局变量BACKUP_DIR是否有效
    if [ -z "$BACKUP_DIR" ] || [ ! -d "$BACKUP_DIR" ]; then
        error "备份目录无效或不存在: $BACKUP_DIR"
        return 1
    fi
    
    local latest_backup="$BACKUP_DIR"
    info "使用备份目录: $latest_backup"
    
    # 检查备份清单
    if [ -f "$latest_backup/backup_manifest.txt" ]; then
        info "备份清单:"
        cat "$latest_backup/backup_manifest.txt"
        printf "\n"
    fi
    
    # 等待服务启动
    info "等待服务启动..."
    sleep 10
    
    # 1. 恢复Python配置文件
    info "恢复Python配置文件..."
    if [ -d "$latest_backup/py/data" ]; then
        mkdir -p "py"
        cp -r "$latest_backup/py/data" "py/"
        success "Python配置文件恢复完成"
    else
        warning "备份中未找到Python配置文件"
    fi
    
    # 2. 恢复用户上传文件
    info "恢复用户上传文件..."
    if [ -f "$latest_backup/uploads_backup.tar.gz" ]; then
        local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
        local uploads_volume="${project_name}_poetize_uploads"
        
        # 等待并确保uploads volume存在
        local actual_uploads_volume=$(sudo docker volume ls --format "{{.Name}}" | grep "$uploads_volume" | head -1)
        if [ -z "$actual_uploads_volume" ]; then
            info "创建用户上传文件volume: $uploads_volume"
            sudo docker volume create "$uploads_volume"
            actual_uploads_volume="$uploads_volume"
        fi
        
        info "恢复到volume: $actual_uploads_volume"
        if sudo docker run --rm -v "$actual_uploads_volume":/data -v "$latest_backup":/backup alpine sh -c "cd /data && tar -xzf /backup/uploads_backup.tar.gz"; then
            success "用户上传文件恢复完成"
        else
            warning "用户上传文件恢复失败"
        fi
    else
        info "备份中未找到用户上传文件"
    fi
    
    # 3. 恢复Redis数据
    info "恢复Redis数据..."
    if [ -f "$latest_backup/redis_backup.tar.gz" ]; then
        local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
        local redis_volume="${project_name}_redis_data"
        
        # 等待并确保redis volume存在
        local actual_redis_volume=$(sudo docker volume ls --format "{{.Name}}" | grep "redis_data" | head -1)
        if [ -z "$actual_redis_volume" ]; then
            info "创建Redis数据volume: $redis_volume"
            sudo docker volume create "$redis_volume"
            actual_redis_volume="$redis_volume"
        fi
        
        info "恢复到volume: $actual_redis_volume"
        if sudo docker run --rm -v "$actual_redis_volume":/data -v "$latest_backup":/backup alpine sh -c "cd /data && tar -xzf /backup/redis_backup.tar.gz"; then
            success "Redis数据恢复完成"
        else
            warning "Redis数据恢复失败"
        fi
    else
        info "备份中未找到Redis数据"
    fi
    
    # 4. 恢复预渲染文件
    info "恢复预渲染文件..."
    if [ -f "$latest_backup/prerender_backup.tar.gz" ]; then
        local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
        local ui_dist_volume="${project_name}_poetize_ui_dist"
        
        # 等待并确保ui_dist volume存在
        local actual_ui_dist_volume=$(sudo docker volume ls --format "{{.Name}}" | grep "poetize_ui_dist" | head -1)
        if [ -z "$actual_ui_dist_volume" ]; then
            info "创建UI构建文件volume: $ui_dist_volume"
            sudo docker volume create "$ui_dist_volume"
            actual_ui_dist_volume="$ui_dist_volume"
        fi
        
        info "恢复预渲染文件到volume: $actual_ui_dist_volume"
        if sudo docker run --rm -v "$actual_ui_dist_volume":/data -v "$latest_backup":/backup alpine sh -c "cd /data && tar -xzf /backup/prerender_backup.tar.gz"; then
            success "预渲染文件恢复完成"
        else
            warning "预渲染文件恢复失败"
        fi
    else
        info "备份中未找到预渲染文件"
    fi
    
    # 5. 重启服务以应用恢复的配置
    info "重启服务以应用恢复的配置..."
    if $DOCKER_COMPOSE_CMD restart; then
        success "服务重启完成"
    else
        warning "服务重启失败，可能需要手动重启"
    fi
    
    # 6. 清理备份目录
    info "清理临时备份目录..."
    if [ -n "$latest_backup" ] && [ -d "$latest_backup" ]; then
        rm -rf "$latest_backup"
        success "临时备份目录已清理: $latest_backup"
    else
        info "备份目录已不存在或路径为空"
    fi
    
    success "用户数据和配置恢复完成"
    return 0
}

# 主要的update函数
run_update() {
    # 显示更新信息
    printf "\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "${GREEN}    POETIZE 系统全量更新工具 v2.0.0${NC}\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "\n"
    
    # 查找项目目录
    find_project_dir

    # 确认操作
    printf "\n"
    printf "${YELLOW}警告：全量更新操作将会：${NC}\n"
    printf "1. 备份当前所有数据和配置\n"
    printf "2. 完全卸载当前POETIZE系统\n"
    printf "3. 重新下载并安装最新版本\n"
    printf "4. 恢复您的数据和配置\n"
    printf "\n"
    printf "${RED}注意：此操作将彻底重建系统！${NC}\n"
    printf "\n"
    read -rp "确认执行全量更新操作？(y/N): " confirm_update

    case "$confirm_update" in
        [Yy]|[Yy][Ee][Ss])
            info "用户确认，开始全量更新..."
            ;;
        *)
            info "用户取消，退出更新"
            exit 0
            ;;
    esac

    # 执行全量更新步骤
    printf "\n"
    info "开始执行全量更新流程..."

    # 1. 备份数据
    info "步骤 1/4: 创建完整数据备份"
    create_full_backup || {
        error "数据备份失败，终止更新"
        exit 1
    }

    # 2. 卸载当前系统
    info "步骤 2/4: 卸载当前POETIZE系统"
    uninstall_services --skip-confirm || {
        error "系统卸载失败，请手动处理"
        exit 1
    }

    # 3. 重新安装系统
    info "步骤 3/4: 重新安装最新版本"
    reinstall_latest_system || {
        error "系统重新安装失败"
        exit 1
    }

    # 4. 恢复数据
    info "步骤 4/4: 恢复用户数据和配置"
    restore_full_backup || {
        error "数据恢复失败，请手动恢复"
        exit 1
    }

    # 完成
    printf "\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "${GREEN}         全量更新完成！${NC}\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "\n"
    success "POETIZE系统已成功更新到最新版本"
    printf "\n"
    info "建议执行以下命令检查系统状态："
    printf "  ${CYAN}poetize -status${NC}    # 查看服务状态\n"
    printf "  ${CYAN}poetize -health${NC}    # 检查服务健康状态\n"
    printf "\n"
}

# 主函数
main() {
    # 检查项目环境
    check_docker
    
    # 解析命令行参数
    case "${1:-}" in
        "-qianyi"|"-migrate"|"-qy")
            run_migration
            ;;
        "-status")
            show_status
            ;;
        "-start"|"-up")
            start_services
            ;;
        "-stop"|"-down")
            stop_services
            ;;
        "-restart")
            restart_services
            ;;
        "-update")
            run_update
            ;;
        "-uninstall")
            uninstall_services
            ;;
        "-uninstall-all")
            uninstall_all_services
            ;;
        "-deploy"|"-bushu"|"-bs")
            run_deployment
            ;;
        "-logs")
            show_logs "$2" "false"
            ;;
        "-logs-follow")
            show_logs "$2" "true"
            ;;
        "-info")
            show_info
            ;;
        "-health")
            check_health
            ;;
        "-version"|"-v")
            show_version
            ;;
        "-help"|"-h"|"")
            show_help
            ;;
        *)
            error "未知选项: $1"
            printf "\n"
            show_help
            exit 1
            ;;
    esac
}

# 运行主函数
main "$@"