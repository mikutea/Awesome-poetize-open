#!/bin/bash
## 作者: LeapYa
## 修改时间: 2025-08-26
## 描述: Poetize 博客系统全局管理命令
## 版本: 1.3.1

# 定义颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 函数
info() { echo -e "${BLUE}[信息]${NC} $1"; }
success() { echo -e "${GREEN}[成功]${NC} $1"; }
error() { echo -e "${RED}[失败]${NC} $1"; }
warning() { echo -e "${YELLOW}[警告]${NC} $1"; }

# 检查用户权限
check_user_permissions() {
    # 检查是否为root用户
    if [ "$EUID" -eq 0 ]; then
        return 0  # root用户，权限充足
    fi
    
    # 检查是否在docker组中
    if groups "$USER" 2>/dev/null | grep -q "\bdocker\b"; then
        return 0  # 在docker组中，权限充足
    fi
    
    # 检查是否有sudo权限
    if sudo -n true 2>/dev/null; then
        # 检查当前是否以sudo方式运行
        if [ -z "$SUDO_USER" ]; then
            warning "当前用户不在docker组中，但具有sudo权限"
            warning "建议使用sudo运行以确保Docker访问权限："
            printf "  ${YELLOW}推荐方式：${NC} sudo poetize [选项]\n"
            printf "  ${YELLOW}或添加到docker组：${NC} sudo usermod -aG docker $USER && newgrp docker\n"
        else
            info "以sudo权限运行，权限充足"
        fi
        return 0  # 有sudo权限，可以继续
    fi
    
    # 权限不足
    error "权限不足！当前用户既不是root用户，也不在docker组中，且无sudo权限"
    error "请执行以下操作之一："
    printf "  ${YELLOW}1. 切换到root用户：${NC} su -\n"
    printf "  ${YELLOW}2. 切换到有sudo权限的用户${NC}\n"
    printf "  ${YELLOW}3. 将当前用户添加到docker组：${NC} sudo usermod -aG docker $USER\n"
    printf "  ${YELLOW}4. 使用sudo运行：${NC} sudo poetize [选项]\n"
    exit 1
}

# 检查Docker和Docker Compose
check_docker() {
    if ! command -v docker &> /dev/null; then
        error "Docker未安装或未在PATH中"
        exit 1
    fi
    
    # 检查用户权限
    check_user_permissions
    
    # 尝试访问Docker
    if ! docker info &> /dev/null; then
        # 如果直接访问失败，尝试使用sudo
        if [ "$EUID" -ne 0 ] && ! groups "$USER" 2>/dev/null | grep -q "\bdocker\b"; then
            if sudo docker info &> /dev/null 2>&1; then
                warning "使用sudo权限访问Docker"
                DOCKER_COMPOSE_CMD="sudo docker-compose"
                # 重新定义docker命令为sudo版本
                alias docker='sudo docker' 2>/dev/null || true
            else
                error "Docker服务未运行或权限不足"
                exit 1
            fi
        else
            error "Docker服务未运行"
            exit 1
        fi
    fi
    
    # 检查docker-compose或docker compose
    if command -v docker-compose &> /dev/null; then
        DOCKER_COMPOSE_CMD="${DOCKER_COMPOSE_CMD:-docker-compose}"
    elif docker compose version &> /dev/null 2>&1 || sudo docker compose version &> /dev/null 2>&1; then
        DOCKER_COMPOSE_CMD="${DOCKER_COMPOSE_CMD:-docker} compose"
    else
        error "Docker Compose未安装"
        exit 1
    fi
}

# 显示帮助信息
show_help() {
    printf "\n"
    printf "${GREEN}██████╗  ██████╗ ███████╗████████╗██╗███████╗███████╗${NC}\n"
    printf "${GREEN}██╔══██╗██╔═══██╗██╔════╝╚══██╔══╝██║╚══███╔╝██╔════╝${NC}\n"
    printf "${GREEN}██████╔╝██║   ██║█████╗     ██║   ██║  ███╔╝ █████╗${NC}\n"
    printf "${GREEN}██╔═══╝ ██║   ██║██╔══╝     ██║   ██║ ███╔╝  ██╔══╝${NC}\n"
    printf "${GREEN}██║     ╚██████╔╝███████╗   ██║   ██║███████╗███████╗${NC}\n"
    printf "${GREEN}╚═╝      ╚═════╝ ╚══════╝   ╚═╝   ╚═╝╚══════╝╚══════╝${NC}\n"
    printf "\n"
    printf "${CYAN}POETIZE 博客系统全局管理工具${NC}\n"
    printf "\n"
    printf "${BLUE}使用方法:${NC}\n"
    printf "  poetize [选项]\n"
    printf "\n"
    printf "${BLUE}服务管理:${NC}\n"
    printf "  -status                   查看所有服务状态\n"
    printf "  -start, -up               启动所有服务\n"
    printf "  -stop, -down              停止所有服务\n"
    printf "  -restart                  重启所有服务\n"
    printf "  -update                   更新系统到最新版本\n"
    printf "  -deploy, -bushu, -bs      执行部署脚本\n"
    printf "\n"
    printf "${BLUE}系统管理:${NC}\n"
    printf "  -qianyi, -migrate, -qy    执行博客迁移到远程服务器\n"
    printf "  -uninstall                卸载当前项目的Poetize实例\n"
    printf "  -uninstall-all            完全卸载所有Poetize系统\n"
    printf "\n"
    printf "${BLUE}日志和监控:${NC}\n"
    printf "  -logs [服务名]            查看服务日志\n"
    printf "  -logs-follow [服务名]     实时跟踪服务日志\n"
    printf "  -health                   检查服务健康状态\n"
    printf "\n"
    printf "${BLUE}信息查看:${NC}\n"
    printf "  -info                     显示系统和项目信息\n"
    printf "  -version, -v              显示版本信息\n"
    printf "  -help, -h                 显示此帮助信息\n"
    printf "\n"
    printf "${BLUE}常用示例:${NC}\n"
    printf "  poetize -status           查看服务状态\n"
    printf "  poetize -restart          重启所有服务\n"
    printf "  poetize -logs nginx       查看nginx日志\n"
    printf "\n"
}

# 显示版本信息
show_version() {
    printf "${GREEN}POETIZE 管理工具 v1.3.1${NC}\n"
    printf "作者: LeapYa\n"
    printf "项目: Awesome-poetize-open\n"
}

find_project_dir() {
    # 查找所有匹配目录，排除常见系统目录
    dirs=()
    while IFS= read -r dir; do
    dirs+=("$dir")
    done < <(sudo find / \
    \( -path /proc -o -path /sys -o -path /dev -o -path /run \) -prune -o \
    -type d -name "Awesome-poetize-open*" -print 2>/dev/null)

    if [ ${#dirs[@]} -eq 0 ]; then
        echo "未发现poetize博客相关目录"
        exit 1
    elif [ ${#dirs[@]} -eq 1 ]; then
        echo "发现一个博客目录: ${dirs[0]}"
        cd "${dirs[0]}" || { echo "切换目录失败: ${dirs[0]}"; exit 1; }
    else
        echo "发现多个博客目录："
        for i in "${!dirs[@]}"; do
            printf "%d. %s\n" "$((i+1))" "${dirs[i]}"
        done

        # 交互输入
        read -rp "请选择要迁移的目录序号: " choice

        # 判断输入有效性
        if ! [[ "$choice" =~ ^[0-9]+$ ]] || (( choice < 1 || choice > ${#dirs[@]} )); then
            echo "无效的选择."
            exit 1
        fi

        target_dir="${dirs[$((choice-1))]}"
        echo "迁移目录: $target_dir"
        cd "$target_dir" || { echo "切换目录失败: $target_dir"; exit 1; }
    fi
}

# 查看服务状态
show_status() {
    info "正在检查POETIZE服务状态..."
    printf "\n"
    
    # 显示Docker容器状态
    printf "${CYAN}=== Docker 容器状态 ===${NC}\n"
    if sudo docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" --filter "name=poetize" | grep -q "poetize"; then
        sudo docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" --filter "name=poetize"
    else
        warning "未发现Poetize相关容器"
    fi
    
    printf "\n"
    
    # 显示服务健康状态
    printf "${CYAN}=== 服务健康状态 ===${NC}\n"
    
    # 检查主要服务（支持多实例）
    local base_services=("poetize-nginx" "poetize-java" "poetize-python" "poetize-mariadb" "poetize-prerender")
    
    # 获取所有运行中的poetize相关容器
    local running_containers=$(sudo docker ps --format "{{.Names}}" | grep "^poetize-" | sort)
    
    # 为每个基础服务类型检查所有实例
    for base_service in "${base_services[@]}"; do
        local found_instances=false
        
        # 检查该服务类型的所有实例
        while IFS= read -r container_name; do
            if [[ "$container_name" =~ ^${base_service}(-blog[0-9]+)?$ ]]; then
                found_instances=true
                local status=$(sudo docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "unknown")
                case "$status" in
                    "healthy")
                        printf "  ${GREEN}✓${NC} %-25s ${GREEN}健康${NC}\n" "$container_name"
                        ;;
                    "unhealthy")
                        printf "  ${RED}✗${NC} %-25s ${RED}不健康${NC}\n" "$container_name"
                        ;;
                    "starting")
                        printf "  ${YELLOW}⚠${NC} %-25s ${YELLOW}启动中${NC}\n" "$container_name"
                        ;;
                    *)
                        printf "  ${BLUE}?${NC} %-25s ${BLUE}运行中${NC}\n" "$container_name"
                        ;;
                esac
            fi
        done <<< "$running_containers"
        
        # 如果没有找到任何实例，显示未运行状态
        if [ "$found_instances" = false ]; then
            printf "  ${RED}✗${NC} %-25s ${RED}未运行${NC}\n" "$base_service"
        fi
    done
    
    printf "\n"
    
    # 显示端口占用情况
    printf "${CYAN}=== 端口占用情况 ===${NC}\n"
    local ports=("80" "443")
    for port in "${ports[@]}"; do
        if netstat -tuln 2>/dev/null | grep -q ":${port} " || ss -tuln 2>/dev/null | grep -q ":${port} "; then
            printf "  ${GREEN}✓${NC} 端口 %-6s ${GREEN}已占用${NC}\n" "$port"
        else
            printf "  ${RED}✗${NC} 端口 %-6s ${RED}未占用${NC}\n" "$port"
        fi
    done
    
    printf "\n"
}

# 启动服务
start_services() {
    find_project_dir
    info "正在启动Poetize服务..."
    
    if $DOCKER_COMPOSE_CMD up -d; then
        success "服务启动成功"
        sleep 3
        show_status
    else
        error "服务启动失败"
        exit 1
    fi
}

# 停止服务
stop_services() {
    find_project_dir
    info "正在停止Poetize服务..."
    if $DOCKER_COMPOSE_CMD down; then
        success "服务停止成功"
    else
        error "服务停止失败"
        exit 1
    fi
}

# 重启服务
restart_services() {
    find_project_dir
    info "正在重启Poetize服务..."

    if $DOCKER_COMPOSE_CMD restart; then
        success "服务重启成功"
        sleep 3
        show_status
    else
        error "服务重启失败"
        exit 1
    fi
}

# 卸载当前项目服务
uninstall_services() {
    local skip_confirm=false
    
    # 检查是否有--skip-confirm参数
    if [ "$1" = "--skip-confirm" ]; then
        skip_confirm=true
    fi
    
    # 只有在非跳过模式下才查找项目目录和显示警告
    if [ "$skip_confirm" = false ]; then
        find_project_dir
        warning "此操作将卸载当前项目的POETIZE系统，包括删除相关容器和数据卷！"
        printf "${RED}警告: 这将删除当前项目的博客数据，此操作不可逆！${NC}\n"
        printf "\n"
        
        # 确认操作
        read -rp "请输入 'YES' 确认卸载当前项目: " confirm
        if [ "$confirm" != "YES" ]; then
            info "卸载操作已取消"
            exit 0
        fi
        info "正在卸载当前项目的POETIZE系统..."
    fi
    
    # 获取当前项目的容器名称（用于识别相关卷）
    local project_containers=$($DOCKER_COMPOSE_CMD ps -q 2>/dev/null || true)
    local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
    
    # 停止并删除当前项目的容器和卷
    info "停止并删除当前项目容器..."
    $DOCKER_COMPOSE_CMD down -v --remove-orphans
    
    # 仅清理通过docker-compose创建的项目专属卷
    info "检查并清理当前项目专属数据卷..."
    
    # 获取当前项目的docker-compose生成的卷名前缀
    local compose_project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
    
    # 清理当前项目的卷（通过docker-compose down -v应该已经删除了，但防止遗漏）
    local project_specific_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "^${compose_project_name}_" || true)
    if [ -n "$project_specific_volumes" ]; then
        info "删除当前项目专属数据卷..."
        while IFS= read -r volume; do
            info "删除数据卷: $volume"
            sudo docker volume rm "$volume" -f 2>/dev/null || true
        done <<< "$project_specific_volumes"
        success "已删除当前项目专属数据卷"
    else
        info "当前项目无需清理额外数据卷（已通过docker-compose清理）"
    fi
    
    success "当前项目的POETIZE系统已卸载"
    
    # 如果是跳过确认模式（用于更新流程），则删除项目目录
    if [ "$skip_confirm" = true ]; then
        local current_dir=$(pwd)
        info "正在删除项目目录..."
        cd ..
        sudo rm -rf "$(basename "$current_dir")"
        info "项目目录已删除"
    else
        warning "如需重新安装，请运行: poetize -deploy"
    fi
}

# 完全卸载所有Poetize系统
uninstall_all_services() {
    warning "此操作将完全卸载所有POETIZE系统，包括删除所有容器、镜像、卷和数据！"
    printf "${RED}警告: 这将删除所有博客数据，此操作不可逆！${NC}\n"
    printf "\n"
    
    # 确认操作
    read -rp "请输入 'YES' 确认完全卸载所有POETIZE系统: " confirm
    if [ "$confirm" != "YES" ]; then
        info "卸载操作已取消"
        exit 0
    fi
    
    info "正在完全卸载所有POETIZE系统..."
    
    # 删除所有poetize相关的容器（包括停止的）
    local containers=$(sudo docker ps -a --format "{{.Names}}" | grep "^poetize-" || true)
    if [ -n "$containers" ]; then
        info "删除所有POETIZE容器..."
        echo "$containers" | xargs sudo docker rm -f
    fi
    
    # 删除所有poetize相关的镜像
    local images=$(sudo docker images --format "{{.Repository}}:{{.Tag}}" | grep "poetize" || true)
    if [ -n "$images" ]; then
        info "删除所有POETIZE镜像..."
        echo "$images" | xargs sudo docker rmi -f
    fi
    
    # 删除所有poetize相关的卷（包括默认卷名和带后缀的卷）
    info "检查并删除所有POETIZE数据卷..."
    
    # 定义需要清理的卷名称模式
    local volume_patterns=(
        "mysql_data"
        "redis_data" 
        "certbot-etc"
        "certbot-var"
        "web-root"
        "poetize_node_modules"
        "im_node_modules"
        "poetize_ui_dist"
        "poetize_im_dist"
        "poetize_uploads"
        "ollama_data"
    )
    
    local volumes_to_delete=()
    
    # 1. 查找包含POETIZE的卷
    local poetize_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "poetize" || true)
    if [ -n "$poetize_volumes" ]; then
        while IFS= read -r volume; do
            volumes_to_delete+=("$volume")
        done <<< "$poetize_volumes"
    fi
    
    # 2. 查找所有可能的默认卷名（包括各种前缀和后缀）
    for pattern in "${volume_patterns[@]}"; do
        # 完全匹配的卷名
        local exact_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "^${pattern}$" || true)
        if [ -n "$exact_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$exact_volumes"
        fi
        
        # 带项目前缀的卷名
        local prefixed_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "_${pattern}$" || true)
        if [ -n "$prefixed_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$prefixed_volumes"
        fi
        
        # 带后缀的卷名（blog2、blog3等）
        local suffixed_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "^${pattern}-blog[0-9]*$" || true)
        if [ -n "$suffixed_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$suffixed_volumes"
        fi
        
        # 带前缀和后缀的卷名
        local complex_volumes=$(sudo docker volume ls --format "{{.Name}}" | grep "_${pattern}-blog[0-9]*$" || true)
        if [ -n "$complex_volumes" ]; then
            while IFS= read -r volume; do
                volumes_to_delete+=("$volume")
            done <<< "$complex_volumes"
        fi
    done
    
    # 去重并删除卷
    if [ ${#volumes_to_delete[@]} -gt 0 ]; then
        # 去重
        local unique_volumes=($(printf "%s\n" "${volumes_to_delete[@]}" | sort -u))
        
        info "找到 ${#unique_volumes[@]} 个POETIZE数据卷，准备删除..."
        for volume in "${unique_volumes[@]}"; do
            info "删除数据卷: $volume"
            sudo docker volume rm "$volume" -f 2>/dev/null || true
        done
        success "已删除 ${#unique_volumes[@]} 个POETIZE数据卷"
    else
        info "未找到需要清理的POETIZE数据卷"
    fi
    
    # 删除所有poetize相关的网络
    local networks=$(sudo docker network ls --format "{{.Name}}" | grep "poetize" || true)
    if [ -n "$networks" ]; then
        info "删除所有POETIZE网络..."
        echo "$networks" | xargs sudo docker network rm
    fi
    
    # 清理未使用的Docker资源
    info "清理未使用的Docker资源..."
    sudo docker system prune -f
    
    success "所有POETIZE系统已完全卸载"
    warning "如需重新安装，请运行: poetize -deploy"
}

# 查看日志
show_logs() {
    local service="$1"
    local follow="$2"
    find_project_dir
    if [ -n "$service" ]; then
        info "正在查看 $service 服务日志..."
        if [ "$follow" = "true" ]; then
            $DOCKER_COMPOSE_CMD logs -f "$service"
        else
            $DOCKER_COMPOSE_CMD logs --tail=100 "$service"
        fi
    else
        info "正在查看所有服务日志..."
        if [ "$follow" = "true" ]; then
            $DOCKER_COMPOSE_CMD logs -f
        else
            $DOCKER_COMPOSE_CMD logs --tail=50
        fi
    fi
}

# 执行迁移
run_migration() {
    info "正在执行博客迁移..."
    # 查找项目目录
    find_project_dir
    if [ ! -f "migrate.sh" ]; then
        error "迁移脚本 migrate.sh 不存在"
        exit 1
    fi
    
    sudo chmod +x migrate.sh
    sudo ./migrate.sh
}

# 执行部署
run_deployment() {
    info "正在启动POETIZE博客系统部署向导..."
    printf "\n"
    
    # 检查是否已在项目目录中
    if [ -f "deploy.sh" ]; then
        warning "检测到当前目录已有POETIZE项目"
        printf "\n"
        read -rp "是否在当前目录重新部署？(y/N): " redeploy_confirm
        case "$redeploy_confirm" in
            [Yy]|[Yy][Ee][Ss])
                info "在当前目录重新部署..."
                find_project_dir
                sudo chmod +x deploy.sh
                sudo ./deploy.sh
                return 0
                ;;
            *)
                info "取消当前目录重新部署"
                ;;
        esac
    fi
    
    # 询问安装位置
    printf "${CYAN}请选择POETIZE博客系统的安装位置：${NC}\n"
    printf "\n"
    printf "当前目录: $(pwd)\n"
    printf "\n"
    
    # 默认安装目录建议
    local default_install_dir="$HOME/poetize-blog"
    
    printf "请输入安装目录路径\n"
    printf "${YELLOW}提示: 直接回车使用默认路径 ($default_install_dir)${NC}\n"
    read -rp "安装目录: " install_dir
    
    # 使用默认目录或用户指定目录
    if [ -z "$install_dir" ]; then
        install_dir="$default_install_dir"
    fi
    
    # 展开波浪号
    install_dir=$(eval echo "$install_dir")
    
    # 验证目录路径
    if [ -d "$install_dir" ] && [ "$(ls -A "$install_dir" 2>/dev/null)" ]; then
        warning "目录 $install_dir 已存在且不为空"
        printf "\n"
        read -rp "是否继续在此目录安装？这可能会覆盖现有文件 (y/N): " continue_install
        case "$continue_install" in
            [Yy]|[Yy][Ee][Ss])
                info "继续在指定目录安装..."
                ;;
            *)
                info "安装已取消"
                exit 0
                ;;
        esac
    fi
    
    # 创建安装目录
    info "准备安装目录: $install_dir"
    mkdir -p "$install_dir"
    cd "$install_dir"
    
    # 显示安装信息
    printf "\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "${GREEN}    POETIZE 博客系统一键部署${NC}\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "\n"
    printf "安装位置: ${CYAN}$install_dir${NC}\n"
    printf "\n"
    
    # 执行一键部署脚本
    bash <(curl -sL deploy.leapya.com)
}

# 显示系统信息
show_info() {
    printf "\n"
    printf "${CYAN}=== 系统信息 ===${NC}\n"
    printf "操作系统: $(uname -s)\n"
    printf "内核版本: $(uname -r)\n"
    printf "架构: $(uname -m)\n"
    printf "\n"
    
    printf "${CYAN}=== Docker 信息 ===${NC}\n"
    printf "Docker版本: $(sudo docker --version 2>/dev/null || echo '未安装')\n"
    printf "Docker Compose: $DOCKER_COMPOSE_CMD\n"
    printf "\n"
    
    printf "${CYAN}=== 项目信息 ===${NC}\n"
    printf "项目路径: $(pwd)\n"
    printf "配置文件: $([ -f '.poetize-config' ] && echo '存在' || echo '不存在')\n"
    printf "数据库凭据: $([ -f '.config/db_credentials.txt' ] && echo '存在' || echo '不存在')\n"
    printf "\n"
}

# 检查服务健康状态
check_health() {
    info "正在检查服务健康状态..."
    printf "\n"

    local all_healthy=true
    local base_services=("poetize-nginx" "poetize-java" "poetize-python" "poetize-mariadb" "poetize-prerender")

    # 获取所有运行中的poetize相关容器
    local running_containers=$(sudo docker ps --format "{{.Names}}" | grep "^poetize-" | sort)

    # 为每个基础服务类型检查所有实例
    for base_service in "${base_services[@]}"; do
        local found_instances=false

        # 检查该服务类型的所有实例
        while IFS= read -r container_name; do
            if [[ "$container_name" =~ ^${base_service}(-blog[0-9]+)?$ ]]; then
                found_instances=true
                printf "${BLUE}检查 $container_name...${NC}\n"

                # 检查容器状态
                local container_status=$(sudo docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null)
                if [ "$container_status" != "running" ]; then
                    printf "  ${RED}✗ 容器未运行 (状态: $container_status)${NC}\n"
                    all_healthy=false
                    continue
                fi

                # 检查健康状态
                local health_status=$(sudo docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "no-healthcheck")
                case "$health_status" in
                    "healthy")
                        printf "  ${GREEN}✓ 健康检查通过${NC}\n"
                        ;;
                    "unhealthy")
                        printf "  ${RED}✗ 健康检查失败${NC}\n"
                        all_healthy=false
                        ;;
                    "starting")
                        printf "  ${YELLOW}⚠ 健康检查启动中${NC}\n"
                        ;;
                    "no-healthcheck")
                        printf "  ${BLUE}? 无健康检查配置${NC}\n"
                        ;;
                esac
            fi
        done <<< "$running_containers"

        # 如果没有找到任何实例，显示未运行状态
        if [ "$found_instances" = false ]; then
            printf "${RED}✗ $base_service 容器未运行${NC}\n"
            all_healthy=false
        fi
    done

    printf "\n"
    if [ "$all_healthy" = true ]; then
        success "所有服务健康状态良好"
    else
        warning "部分服务存在问题，请检查日志"
    fi
}

# ================================ UPDATE 命令相关函数 ================================

# 创建完整数据备份
create_full_backup() {
    info "数据备份..."
    return 0
}

# 重新安装最新系统
reinstall_latest_system() {
    info "开始重新安装最新版本的POETIZE系统..."
    bash <(curl -sL deploy.leapya.com)
    
    success "最新版本系统安装完成"
    return 0
}

# 恢复完整备份
restore_full_backup() {
    info "开始恢复用户数据和配置..."
    
    success "用户数据和配置恢复完成"
    return 0
}

# 主要的update函数
run_update() {
    # 显示更新信息
    printf "\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "${GREEN}    POETIZE 系统全量更新工具 v2.0.0${NC}\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "\n"
    
    # 查找项目目录
    find_project_dir

    # 确认操作
    printf "\n"
    printf "${YELLOW}警告：全量更新操作将会：${NC}\n"
    printf "1. 备份当前所有数据和配置\n"
    printf "2. 完全卸载当前POETIZE系统\n"
    printf "3. 重新下载并安装最新版本\n"
    printf "4. 恢复您的数据和配置\n"
    printf "\n"
    printf "${RED}注意：此操作将彻底重建系统！${NC}\n"
    printf "\n"
    read -rp "确认执行全量更新操作？(y/N): " confirm_update

    case "$confirm_update" in
        [Yy]|[Yy][Ee][Ss])
            info "用户确认，开始全量更新..."
            ;;
        *)
            info "用户取消，退出更新"
            exit 0
            ;;
    esac

    # 执行全量更新步骤
    printf "\n"
    info "开始执行全量更新流程..."

    # 1. 备份数据
    info "步骤 1/4: 创建完整数据备份"
    create_full_backup || {
        error "数据备份失败，终止更新"
        exit 1
    }

    # 2. 卸载当前系统
    info "步骤 2/4: 卸载当前POETIZE系统"
    uninstall_services --skip-confirm || {
        error "系统卸载失败，请手动处理"
        exit 1
    }

    # 3. 重新安装系统
    info "步骤 3/4: 重新安装最新版本"
    reinstall_latest_system || {
        error "系统重新安装失败"
        exit 1
    }

    # 4. 恢复数据
    info "步骤 4/4: 恢复用户数据和配置"
    restore_full_backup || {
        error "数据恢复失败，请手动恢复"
        exit 1
    }

    # 完成
    printf "\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "${GREEN}         全量更新完成！${NC}\n"
    printf "${GREEN}===========================================${NC}\n"
    printf "\n"
    success "POETIZE系统已成功更新到最新版本"
    printf "\n"
    info "建议执行以下命令检查系统状态："
    printf "  ${CYAN}poetize -status${NC}    # 查看服务状态\n"
    printf "  ${CYAN}poetize -health${NC}    # 检查服务健康状态\n"
    printf "\n"
}

# 主函数
main() {
    # 检查项目环境
    check_docker
    
    # 解析命令行参数
    case "${1:-}" in
        "-qianyi"|"-migrate"|"-qy")
            run_migration
            ;;
        "-status")
            show_status
            ;;
        "-start"|"-up")
            start_services
            ;;
        "-stop"|"-down")
            stop_services
            ;;
        "-restart")
            restart_services
            ;;
        "-update")
            run_update
            ;;
        "-uninstall")
            uninstall_services
            ;;
        "-uninstall-all")
            uninstall_all_services
            ;;
        "-deploy"|"-bushu"|"-bs")
            run_deployment
            ;;
        "-logs")
            show_logs "$2" "false"
            ;;
        "-logs-follow")
            show_logs "$2" "true"
            ;;
        "-info")
            show_info
            ;;
        "-health")
            check_health
            ;;
        "-version"|"-v")
            show_version
            ;;
        "-help"|"-h"|"")
            show_help
            ;;
        *)
            error "未知选项: $1"
            printf "\n"
            show_help
            exit 1
            ;;
    esac
}

# 运行主函数
main "$@"